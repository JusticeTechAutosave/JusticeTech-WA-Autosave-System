// plugins/googlerestore.js â€” JusticeTech Autosave Bot v1.1.1 JT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// USAGE:  .googlerestore <code>  |  .restoregoogle <code>
//
// Restores the full bot backup from a code generated by .googlebackup.
// Handles ALL three code formats:
//   v3 compact  â€” { _v:3, _at, data:{...} }  (from makeRestoreCode in googlebackup)
//   full bundle â€” { _meta, data, database, settings }
//   legacy      â€” { users:{...} }  (old token-only format)
//
// Owner and premium users can restore their own backup.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

"use strict";

const fs   = require("fs");
const path = require("path");
const zlib = require("zlib");

const {
  TOKENS_FILE,
  HOME_BACKUP_FILE,
  getUserAccounts,
  normalizeNumber,
} = require("../library/googleTenantAuth");
const { invalidateContactsCache } = require("../library/googleContacts");

const BOT_ROOT     = path.join(__dirname, "..");
const DATA_DIR     = path.join(BOT_ROOT, "data");
const DB_DIR       = path.join(BOT_ROOT, "database");
const SETTINGS_DIR = path.join(BOT_ROOT, "settings");

function jidFromCtx(m) {
  return m?.sender || m?.key?.participant || m?.key?.remoteJid || "";
}

// Auto-detect gzip (new format) or plain base64 (old format)
function decodeCode(code) {
  const cleaned = code.replace(/\s+/g, "");
  const buf     = Buffer.from(cleaned, "base64");

  // Gzip magic bytes: 0x1f 0x8b
  if (buf[0] === 0x1f && buf[1] === 0x8b) {
    const json = zlib.gunzipSync(buf).toString("utf8");
    return JSON.parse(json);
  }

  // Old plain-base64 fallback
  return JSON.parse(buf.toString("utf8"));
}

// Full bundle: { _meta, data, database, settings }
function isFullBundle(obj) {
  return !!(obj?._meta && (obj.data || obj.database));
}

// Compact v3 restore code: { _v:3, _at, data:{ "google_tokens.json":{...} } }
function isCompactV3(obj) {
  return obj?._v === 3 && obj?.data && typeof obj.data === "object";
}

function restoreDir(files, dir) {
  if (!files || typeof files !== "object") return 0;
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  let count = 0;
  for (const [filename, content] of Object.entries(files)) {
    if (!filename.endsWith(".json")) continue;
    try {
      fs.writeFileSync(path.join(dir, filename), JSON.stringify(content, null, 2));
      count++;
    } catch {}
  }
  return count;
}

module.exports = {
  name: "GoogleRestore",
  category: "autosave",
  desc: "Restore full bot backup from a .googlebackup code (owner/premium)",
  command: ["googlerestore", "restoregoogle"],
  premiumOnly: true,

  run: async ({ reply, m, args, botNumber, botJid, sock, isOwner, isDev, isPremium }) => {
    // Allow dev, owner, and premium users
    if (!isDev && !isOwner && !isPremium) {
      return reply("ðŸ”’ This feature requires an active premium subscription.");
    }

    const code = (args || []).join("").trim();
    if (!code) {
      return reply(
        `Usage: .googlerestore <backup_code>\n\n` +
        `Get the code from the restore code message sent with your .googlebackup.\n\n` +
        `ðŸ’¡ On the same server, tokens auto-restore from the server backup on startup.\n` +
        `Try restarting first if you're on the same server.`
      );
    }

    await reply("â³ Decoding backup...");

    let bundle;
    try {
      bundle = decodeCode(code);
    } catch (e) {
      return reply(
        `âŒ Could not decode the backup code.\n\nError: ${e.message}\n\n` +
        `âš ï¸ Make sure you copied the FULL restore code â€” it may span multiple lines.\n` +
        `The restore code starts right after ".googlerestore " â€” copy everything after that.`
      );
    }

    let restored = 0;

    if (isCompactV3(bundle)) {
      // âœ… Compact v3 format â€” from makeRestoreCode() in googlebackup.js
      // Contains: data/google_tokens.json + data/oauth_config.json + data/google_auth.json
      restored += restoreDir(bundle.data, DATA_DIR);

    } else if (isFullBundle(bundle)) {
      // Full bundle format with data/, database/, settings/
      restored += restoreDir(bundle.data,     DATA_DIR);
      restored += restoreDir(bundle.database, DB_DIR);
      restored += restoreDir(bundle.settings, SETTINGS_DIR);

    } else if (bundle?.users) {
      // Legacy token-only format
      if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
      fs.writeFileSync(TOKENS_FILE, JSON.stringify(bundle, null, 2));
      restored = 1;

    } else {
      return reply(
        `âŒ Backup code does not contain valid bot data.\n\n` +
        `This code was not generated by .googlebackup, or it may be corrupted.\n` +
        `Make sure you're using the *Restore Code* message (not the .txt document).`
      );
    }

    if (restored === 0) {
      return reply("âš ï¸ Backup decoded but no files were restored. Is the backup empty?");
    }

    // Refresh home-dir backup with restored tokens
    try {
      const tokensObj = bundle?.data?.["google_tokens.json"] || (bundle?._v === 3 ? null : bundle);
      if (tokensObj) {
        fs.writeFileSync(HOME_BACKUP_FILE, JSON.stringify(tokensObj, null, 2));
      }
    } catch {}

    // Invalidate contacts cache for all restored owners
    try {
      const tokensData = bundle?.data?.["google_tokens.json"] || (bundle?.users ? bundle : null);
      if (tokensData?.users) {
        for (const owner of Object.keys(tokensData.users)) {
          invalidateContactsCache(owner);
        }
      }
    } catch {}

    // Invalidate subscription in-memory cache so restored data is loaded fresh
    try {
      const { invalidateCache } = require("../library/subscriptionDb");
      invalidateCache();
    } catch {}

    const botNum = normalizeNumber(
      botNumber || (botJid ? String(botJid).split("@")[0] : "") ||
      (sock?.user?.id ? String(sock.user.id).split(":")[0].split("@")[0] : "")
    );
    const accounts    = botNum ? getUserAccounts(botNum) : [];
    const accountList = accounts.length
      ? accounts.map((a, i) => `  ${i + 1}. ${a.email}`).join("\n")
      : "  (run .googleaccounts to check)";

    const meta = bundle?._meta;
    const bundleType = isCompactV3(bundle) ? "Restore Code (auth tokens)" : isFullBundle(bundle) ? "Full Bundle" : "Legacy tokens";

    return reply([
      `âœ… *Bot Backup Restored!*`,
      ``,
      `ðŸ“¦ Format: ${bundleType}`,
      meta?.createdAt ? `ðŸ“… Backup from: ${meta.createdAt.split("T")[0]}` : bundle?._at ? `ðŸ“… Backup from: ${String(bundle._at).split("T")[0]}` : "",
      meta?.hostname  ? `ðŸ–¥ï¸  Original host: ${meta.hostname}` : "",
      ``,
      `ðŸ“ Files restored: ${restored}`,
      isFullBundle(bundle) ? `\nðŸ“‹ *Restored includes:*\n  â€¢ Google auth tokens\n  â€¢ Subscription database\n  â€¢ Bot settings & config\n  â€¢ Prefix, ban list, referrals\n  â€¢ Autobackup config` : "",
      ``,
      `ðŸ“‹ *Google accounts:*`,
      accountList,
      ``,
      `ðŸ”„ Contacts & subscription cache cleared.`,
      `âœ… Restore complete â€” no re-linking needed!`,
      ``,
      `Run .googleaccounts to confirm linked accounts.\nRun .substatus to verify subscriptions.`,
    ].filter(l => l !== null && l !== undefined).join("\n"));
  },
};
